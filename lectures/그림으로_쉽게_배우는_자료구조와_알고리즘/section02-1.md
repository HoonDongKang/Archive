## 💻 개요

### 📌 배열

**선언**
배열의 크기와 함께 변수로 선언하면 **연속된 메모리 공간**을 찾아 할당한다. 해당 메모리에 배열 요소들을 할당하고 **남은 메모리 공간은 쓰레기 값**으로 할당해둔다. 이후, 남은 배열 공간에 값을 할당하면 쓰레기 값이 차지하던 주소에 **데이터를 덮어** 씌운다.

-   운영체제는 **배열의 시작 주소만**을 기억한다.
-   배열의 인덱스 값을 통해 조회시, 운영체제는 배열의 시작 주소에 인덱스를 더해 데이터를 반환한다. (**효율적인 참조 성능**)
-   하지만 **데이터 삽입, 삭제 성능은 비효율적**이다.

```c
// 6 ~ 10 은 쓰레기 값 할당
int arr[10] = {1, 2, 3, 4, 5};

// 배열의 남은 공간에 데이터를 삽입하면 쓰레기 값 -> 데이터로 덮어씌움
arr[5] = 6;
arr[6] = 7;

// ✅ 만약 배열의 크기를 넘어서 할당하려면?
// 뒤 메모리 공간에 중요한 정보가 있을 수도 있으니 기존 메모리 공간을 확장할 수는 없다.
// 새로운 연속된 메모리 공간을 찾아서 배열을 복사하여 할당.
// 데이터 삽입, 삭제 성능은 비효율적
```

-   `Javascript`의 경우, 배열은 객체이다.
-   대부분 불연속적인 메모리 공간을 할당하여 배열을 생성한다.

### 📌 연결리스트

#### ✅ 개념

-   배열의 단점을 해소하기 위해 등장
-   메모리 공간에 **분산**하여 데이터를 저장하고, 해당 데이터들을 **연결**시켜준다.
-   각 데이터를 **노드**라고 칭하며, 노드는 `data`와 다음 노드의 주소를 담는 `next`를 저장한다.
-   첫 노드의 주소만 알고 있다면, 그 이후의 노드 또한 접근할 수 있다.

⭕️ **데이터 삽입 및 삭제**

-   배열에서 중간에 데이터를 삽입하기 위해서 **이후 데이터를 모두 한 칸 씩 뒤로** 미뤄서 저장시켜줘야 했음
-   연결리스트는 삽입하려는 데이터의 노드를 생성하고 **삽입 위치의 앞, 뒤 노드의 연결만 수정**해주면 쉽게 삽입이 가능
-   삭제도 마찬가지.

❌ **데이터 참조**

-   배열은 연속된 메모리 공간이 할당되어, 접근의 **시간 복잡도는 O(1)**
-   연결리스트는 데이터가 분산되어 있기 때문에, 첫 번째 노드부터 순서대로 노드를 참조해가며 데이터에 접근 - **시간 복잡도 O(n)**

|                   | 배열 | 연결리스트 |
| ----------------- | ---- | ---------- |
| 크기              | 고정 | 동적       |
| 주소              | 연속 | 불연속     |
| 데이터 참조       | O(1) | O(n)       |
| 데이터 삽입, 삭제 | O(n) | O(n)       |

-   참조가 많이 이루어지는 상황: **배열**
-   삽입, 삭제가 많이 이루어지는 상황: **연결리스트**

#### ✅ 구현

**추상자료형** : 데이터와 해당 데이터를 다루는 연산을 함께 묶어 추상적으로 정의

**연결리스트의 추상자료형**

1. `printAll()`: 모든 데이터 출력
2. `clear()`: 모든 데이터 제거
3. `insertAt(index, data)`: 인덱스 데이터 삽입
4. `insertLast(data)`: 마지막 데이터 삽입
5. `deleteAt(index)`: 인덱스 데이터 삭제
6. `deleteLast()`: 마지막 데이터 제거
7. `getNodeAt(index)`: 인덱스 데이터 조회

### 📌 더 찾아본 점

**❓ 자바스크립트에서의 배열**

1. **동적 크기 조정 가능**
    - 자바스크립트 배열은 동적으로 크기가 조정된다.
    - 새로운 요소를 추가하거나 제거하면 그에 맞춰 배열의 크기가 변경된다.
2. **다양한 데이터 타입 저장 가능**
    - `number`, `string`, `boolean`, `object` 등 다양한 타입의 데이터가 배열에 저장될 수 있다.
    - 자바스크립트의 배열을 객체이기 때문에, **객체의 프로퍼티**로 모든 데이터 타입이 저장 가능하다.
3. **타입은 객체(`object`) 이지만 배열 메서드를 제공한다.**
    - `push()`, `pop()`, `map()` 등 배열에서 사용가능한 메서드를 제공한다.

**❓ `typeof([])`는 왜 `object`로 결과가 나올까?**

✅ `typeof` 연산자는 매개변수의 자료형이 **원시 값**인지, **참조 값**인지를 구분해준다. 자바스크립트 배열의 `prototype`을 보면 `Array.prototype`을 갖고 그 상위 프로토타입은 `Object.prototype`을 갖는다. 그렇기에 결국 배열은 객체의 프로토타입을 상속받고 있기에 참조값이며 `object`가 반환된다.

**❓ 원시 값, 참조 값이 뭐야?**

✅ **원시 값(Primitive Value)**은 값이 변경될 수 없고(immutable), 직접 값이 저장되는 데이터 형태를 의미한다. 새로운 값을 변수에 저장하면 메모리 주소에 해당 값이 그대로 저장되며 변수에 값을 변경시키면 새로운 메모리에 값을 할당시킨다. 즉, 기존 메모리 주소에 저장된 값을 변경시킬 수 없다.

-   `undefined`, `boolean`, `number`, `string` ,,

**참조 값(Reference Value)**는 값이 변경 가능(mutable)하고 참조형 데이터를 의미한다. 변수가 직접 값을 저장하는 것이 아닌 해당 값이 위치한 메모리 주소를 참조한다. 객체의 프로퍼티 값을 변경하게 되면 해당 메모리를 참조하는 모든 변수들이 영향을 받는다.

-   `Object`, `Array`, `Function`

**❓ `typeof([])`는 그럼 왜 배열 메서드를 사용할 수 있는가?**

✅ `arr → Array.prototype → Object.prototype → null` 이런 프로토타입 체인을 갖고 있기 때문에, 결국 배열은 `Array.prototype`에서 제공하는 메서드를 상속받아서 사용할 수 있다.

출처: [그림으로 쉽게 배우는 자료구조와 알고리즘](https://www.inflearn.com/course/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EB%B3%B8/dashboard)
