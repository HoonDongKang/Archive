## 💻 가상메모리

### 📌 개요

프로세스는 물리 메모리에 직접 접근하지 않아도 메모리 관리자를 통해 물리 메모리로 연결한다.

32bit CPU = 2^32 = 약 4기가의 가상 메모리

**❓그러면 가상 메모리의 용량을 뛰어넘는 프로세스들을 어떻게 실행되는 것인가?**

-   물리 메모리 내용의 일부를 하드디스크의 스왑 영역으로 이동
-   치리가 필요할 때마다 물리메모리로 가져와서 실행

메모리 관리자는 물리메모리와 스왑영역을 합친 영역에서 가상주소를 물리주소로 변환 **(동적 주소 변환 DAT)**

-   물리 메모리의 0번지는 운영체제 영역이라 사용할 수 없음
-   나머지 영역에 대해 메모리 관리자는 "가변 분할 방식(세그멘테이션)"과 "고정 분할 방식(페이징)"으로 구분하여 나눈다.
    -   세그멘테이션-페이징 혼용기법 사용

메모리 관리자는 **매핑 테이블**(가상주소와 물리 주소 1:1 매핑)을 통해 가상 주소를 물리주소로 저장

### 📌 세그멘테이션(배치정책)

세그멘테이션: 함수, 모듈 등으로 세그먼트를 분할(코드, 힙, 데이터, 스택,,)

-   프로그램 관점에서는 각 세그먼트는 분리되어 있다고 판단 <-> 프로세스는 코드, 데이터, 힙, 스택 영역은 인접하다고 판단

**논리 주소**: 사용자, 프로세스, CPU
**물리 주소**: 물리 메모리

**세그멘테이션 테이블**

-   메모리관리자가 관리
-   Base Address, Bound Address 가 저장

**논리주소에서 물리주소 변환 과정**

1. CPU가 논리주소, 세그멘트 번호 전달
2. 메모리 관리자는 Segment Table Base Register 를 통해 물리 메모리 n 번지에 저장된 세그먼테이션 테이블을 로드
3. 세그멘트 번호를 인덱스로 테이블에서 Base Address, Bound Address 조회
4. Bound Address(메모리 크기)와 논리 주소를 비교
    1. Bound Address > 논리 주소 = Base Address + 논리 주소 = 물리 주소
    2. Bound Address < 논리 주소 = 메모리 침범 -> 에러 발생

-   컨텍스트 스위칭마다 해당 세그멘테이션 테이블에 프로세스의 데이터를 수정 -> 비용이 큰 작업

**장점**

-   각 세그멘테이션이 모듈로 처리되어 분할이 가능하기에 관리가 편함

**단점**

-   외부 단편화 발생 가능

### 📌 페이징(배치정책)

고정 분할 방식: 메모리를 정해진 크기의 페이지로 나누어 관리

-   논리주소공간: 사용자, 프로세스가 바라보는 공간
    -   일정한 크기로 균일하게 구분(페이지)
-   물리주소공간: 실제 메모리에서 사용되는 주소 공간
    -   일정한 크기로 균일하게 구분(프레임)

**페이지 테이블**

1. CPU 논리주소 전달
2. 메모리 관리자는 Page Table Base Register을 통해 물리메모리 n번지에서 페이지 테이블 로드
3. 페이지 번호 = 논리주소 / 페이지 크기
4. 오프셋은 논리주소 % 페이지 크기
5. 페이지 테이블에서 페이지 번호를 인덱스로 프레임, 오프셋를 알아냄
6. 만약 프레임에 `invalid`로 저장되면 스왑영역에 저장

**예시**

1. 2^32 바이트의 CPU는 약 4GB의 가상 메모리 사용
2. 2^24 바이트는 페이지 크기(16MB), 2^8 바이트는 페이지 번호(256개)로 구분
3. 첫 페이지의 마지막 주소는 16777217 (16MB - 2^16)
4. 논리주소 0x31553322 번호 찾기
5. 31553322 / 1677217 = 1...14777216
6. 인덱스번호 1, 오프셋 14777216
7. 페이지 테이블 1번 인덱스의 프레임 번호 + 14777216이 물리주소

**차이점**

1. 세그멘테이션은 Base Address가 필요하지만 페이징은 각 페이지 영역이 동일하여 필요 없음
2. 세그멘테이션 외부 단편화 발생, 페이징 내부 단편화 발생
3. 세그멘테이션 논리적 영역별로 구분, 페이징은 고정된 페이지에 저장하여야 하니 논리적으로 구분 불가
4. 각 프로세스마다 페이지 테이블을 갖고 있기에, 페이지 테이블의 크기 관리가 중요하다.

### 📌 페이지드 세그멘테이션

페이지드 세그멘테이션: 페이지 + 세그멘테이션

메모리 접근 권한 : 메모리 특정 번지에 대한 접근 권한 (R, W, E)

**프로세스**

-   코드: RE
-   데이터: RW(o)
-   힙: RW
-   스택: RW

권한이 없는 메모리 접근 시, 에러 발생

-   세그멘테이션 테이블에 권한 비트 추가
-   Base Address -> Page Number
-   Bound Address -> 세그먼트의 페이지 개수(사실상 동일한 값)

**예시**

1. CPU가 0x12300번지 접근 요청
2. 메모리 관리자가 메모리에서 세그멘테이션 테이블이랑 페이지 테이블 로드
3. 세그먼트 번호를 통해 인덱스를 확인 후, 접근 권한 위반 여부를 파악
4. 페이지 넘버를 통해 페이지 테이블의 프레임 확인
5. 물리 메모리의 프레임 번호 + 접근 요청된 메모리 오프셋 = 물리 주소

**단점**

1. 물리메모리에서 데이터를 가져오기 위해서는 메모리 접근 두 번 해야함 (세그멘테이션 테이블, 페이지 테이블)

### 📌 디멘드 페이징(가져오기 정책)

**지역성 이론**

1. 공간의 지역성: 현재 위치에서 가까운 데이터에 접근 확률이 높음
2. 시간의 지역성: 현재 시간에서 가까운 데이터에 접근 확률이 높음(최근)

**디멘드 페이징**: 필요한 데이터만 메모리에 올리고 사용하지 않는 데이터는 스왑 영역으로 이동

메모리 계층 구조

-   레지스터
-   캐시
-   메인 메모리
-   보조저장장치

보조저장장치에서 데이터를 가져오는 것은 레지스터보다 몇 배는 더 많은 시간이 소요
스왑영역이 보조저장장치에 있기에, 스왑영역에 데이터를 저장하는 것을 최소화해야 함.

**스왑 인(swap in)**: 스왑 영역 -> 물리 메모리
**스왑 아웃(swap out)**: 물리 메모리 -> 스왑 영역

페이지 테이블 엔트리(PTE)

1. 접근 비트: 데이터 접근 여부(읽기, 실행 작업 시, 1)
2. 변경 비트: 데이터 쓰기 여부(쓰기 작업 시, 1)
3. 유효 비트: 페이지가 물리 메모리에 있는지(있음 0)
4. WRE 비트: 접근 권한 비트
5. 프레임: 프레임 번호 저장

**디멘드 페이징 과정**

1. 페이지 테이블에서 유효비트와 프레임 번호를 확인
2. 유효비트가 0일 경우, 물리 메모리에서 해당 프레임 번호로 데이터 반환
3. 1일 경우, 스왑영역에서 프레임 번호로 데이터 추출
4. 물리 메모리에서 빈 프레임을 확인
5. 빈 프레임이 있으면 물리 메모리로 데이터를 적재하고 페이지 테이블 수정
6. 빈 프레임이 없으면 물리 메모리에서 필요하지 않은 데이터를 스왑 영역으로 이동 후, 빈 프레임으로 이동

### 📌 더 찾아본 점

**❓ 페이징, 세그멘테이션, 페이지드 세그멘테이션**
✅
**페이지 테이블 엔트리**: 페이지 테이블에서 페이지에 대한 위치 정보를 담은 각 행
**페이징 테이블 구성**
|페이지 번호|프레임번호|유효/무효 비트|
|-|-|-|
|0|5|v|
|1|8|v|
|2|3|i|

1. CPU가 (p,d) 논리주소 전달
2. 페이징 테이블에서 p에 대한 f를 찾고 반환 (i일 경우, trap)
3. 물리 주소 = f 번 프레임의 d 번째 위치 = 페이지 크기 \* f + d

**세그멘테이션 테이블 엔트리**: 세그멘트 테이블에서 세그멘트 주소 정보를 담은 각 행
**세그멘테이션 테이블 구성**
|세그먼트 번호|Base Address|Bound Address (limit)|
|-|-|-|
|0|1000|400|
|1|5000|300|
|2|8000|1000|

1. CPU가 (s,d) 논리주소 전달
2. 세그먼트 테이블에서 s에 대한 base address와 limit 확인
3. d가 limit 보다 크면 에러
4. 물리 주소 = base address + d

**페이지드 세그멘테이션**: 프로세스를 각 세그멘테이션으로 구분하고 세그멘테이션을 고정 크기의 페이지로 분할

-   세그멘테이션 테이블과 페이지 테이블 모두 사용
-   해당 세그먼트 안에 페이지 주소를 찾고 페이지 주소에 오프셋 값을 더해 원하는 데이터 추출

| 세그먼트 번호 | 권한 비트 | 페이지 넘버 | 페이지 개수 |
| ------------- | --------- | ----------- | ----------- |
| 0             | RW        | 2           | 500         |
| 1             | RW        | 0           | 1000        |
| 2             | W         | 1           | 1200        |

| 인덱스 | 프레임 |
| ------ | ------ |
| 0      | 3      |
| 1      | 1      |
| 2      | i      |

1. CPU는 (s,p,d) 논리주소 전달
2. 세그먼트 번호를 통해 p를 확인하고 d와 페이지 개수를 비교하여 메모리 침범인지 확인
3. p를 통해 페이지 테이블에서 인덱스를 확인하고 프레임 번호를 확인
4. 물리 주소: 프레임 번호 시작 주소 + d = f \* 페이지 크기 + d

**❓ 메모리에 없는(invalid)데이터를 어떻게 저장장치에서 가져올까?**

✅ **Demand Paging**: 프로그램 실행 중에 필요한 페이지만 물리 메모리에 저장하고, 실행 중에 요구되는 페이지에 대해서는 저장장치에서 로드
**Page Fault**: 페이지 테이블에서 가져오려는 데이터가 invalid 한 상황. 운영체제에게 trap을 발동시키고 이를 통해 요구되는 페이지를 메모리로 로드

![page_fault](./public/page_fault.png)

1. 페이지 테이블에서 찾으려난 데이터가 valid인지 invalid인지 확인
2. invalid일 경우, page fault가 발생되고 운영체제의 trap에 걸림(프로세스 대기).
3. 물리 메모리에서 비어있는 frame 주소를 찾음
4. 제 2 저장장치에서 요구되는 페이지를 찾고 해당 프레임에 할당
5. 물리 주소 프레임 위치를 페이지 테이블에 매핑
6. 인터럽트가 끝나고 프로세스 중단된 명령어부터 다시 실행

### 📌 백엔드 면접 질문

**✏️ 페이지 폴트(Page Fault)는 언제 발생하며, 운영체제는 이를 어떻게 처리하는가??**

✅ 페이지 폴트란 프로세스가 논리 주소로 데이터를 요청할 때, 메인 메모리에 데이터가 없는 경우 발생하는 인터럽트이다.
스왑 영역에 저장되어 있는 페이지를 가져오기 위해 프로세스를 대기 상태로 변경 시켜, 운영체제에 트랩을 발생시키고
스왑 영억에서 데이터를 가져와 메인 메모리에 저장하고 페이지 테이블을 다시 변경해서 프로세스를 이어서 실행시킵니다.

**✏️ Node.js에서 가상메모리는 어떻게 관리되는가?**
V8 엔진은 JS코드가 저장되는 `Code segment`, 함수 호출과 실행 컨텍스트를 저장하는 `Call Stack`, 객체와 데이터를 저장하는 `Heap Memory`로 구분된다. V8에서는 페이징 기법을 통해 힙 영역을 가상 메모리로 관리한다. 힙 영역에 각각의 space(new space, old space, large object space,,)들은 페이지로 구성되어 있으며 각 페이지는 large object space를 제외하고는 1MB정도이다. 또한 가비지 컬렉터를 통해 단편화가 많이 일어난 페이지에 대해 메모리 압축을 진행한다. - 살아있는 객체들을 한 곳으로 이동시키고 포인터 갱신

출처: [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)
