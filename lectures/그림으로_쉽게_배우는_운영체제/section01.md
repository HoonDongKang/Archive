## 💻 운영체제 들어가기

### 📌 개요

개인용 컴퓨터: Windows / MacOS
대형 컴퓨터, 서버: Unix / Linux
스마트폰, 테블릿: Android / IOS
스마트워치, 냉장고, 세탁기: Embeded OS

❓컴퓨터는 운영체제가 있어야 동작하는가?
✅ 없어도 동작은 가능하지만 처음 설계를 제외한 다른 기능 추가가 불가(유연성 X) - 전화기(통화만 가능) / 스마트폰(업데이트 및 설치)

#### 운영체제가 하는 일

1️⃣ 프로세스 관리 **(CPU)**
→ 여러 프로그램을 동시에 실행하고, CPU 자원을 효율적으로 배분

2️⃣ 메모리 관리 **(메모리)**
→ 실행 중인 프로그램이 필요한 메모리를 할당하고 관리

3️⃣ 하드웨어 관리 **(하드웨어)**
→ 키보드, 마우스, 프린터 등 장치를 제어하고 하드디스크 특정 영역의 데이터 저장관리

4️⃣ 파일 시스템 관리 **(파일)**
→ 하드디스크의 효율적인 파일 저장과 관리

### 📌 역사

#### 🗓️ 1940년대

-   미국 펜실베니아 대학교에서 미국 탄도 계산을 위해 **30톤 무게**의 전자 디지털 계산기 발명
-   종이에 수기로 작성하여 테스트 진행 후, **수동으로 스위치와 배선**을 연결하여 프로그래밍
-   펀치 카드를 이용한 **입출력은 속도가 느리며 진공관의 유지 보수 비용도 크다**.
-   하드웨어의 비용이 비싸기에,**CPU의 효율적인 활용**이 중요해진다.

#### 🗓️ 1950년대

-   아주 작은 크기의 **직접회로** 개발.
-   컴퓨터가 삽입된 **펀치카드를 직접 읽어** 계산하고 프린터로 출력.
-   **기존 과정** (오버헤드 과다 발생)
    1. 프로그래머가 오퍼레이터에게 펀치카드 전달.
    2. 펀치카드를 컴퓨터에 삽입 후, 결과 도출.
    3. 오퍼레이터가 결과를 프로그래머에게 전달.
-   **싱글 스트림 배치 시스템 (Single-stream Batch Processing Systems)**
    1. 오퍼레이터에게 여러개의 펀치카드를 전달.
    2. 컴퓨터는 다수의 펀치카드를 한 번에 하나씩 읽어가며 결과를 도출
-   **입출력 관리자(I/O Device Controller)** 를 개발하여 입출력 중에도 CPU 계산 가능
    -   입출력이 끝나면 CPU에게 **인터럽트** 신호를 주고, CPU는 신호를 받아 처리
    -   출력은 CPU와 입출력 관리자 분리가 가능하지만, **입력**은 작업이 완료되어야지만 처리가 가능하여 어쩔 수 없이 **CPU의 대기가 필요해짐**.

#### 🗓️ 1960년대

-   **시분할 시스템(Time Sharing System)**
    -   CPU 시간을 여러 개의 프로그램에 분배하여 동시에 실행되는 것 같은 효과 제공
-   하나의 컴퓨터에 다수의 터미널을 연결시켜, 여러 사용자의 작업이 가능해짐.
-   벨 연구소에서 **유닉스(UNIX)** 운영체제 개발
    -   **멀티 프로그래밍**: 여러 개의 프로그램 동시 실행 가능
    -   **다중 사용자**: 여러 사용자가 한 대의 컴퓨터를 공유하여 사용
    -   **트리구조 파일 시스템**: 루트("/")를 기준으로 파일과 디렉터리가 계층형 구조로 정리
    -   **보안 및 접근 권한**: 파일, 디렉터리에 대한 권한('r', 'w', 'x') 설정 가능
    -   **높은 이식성**: 다양한 하드웨어에 쉽게 적용 가능
    -   **쉡 기반 CLI 제공**: GUI가 아닌 CLI를 통해 운영
-   여러 프로그래밍 간 메모리 영역을 침범하는 문제 발생

#### 🗓️ 1970 ~ 1980년대

-   개인용 컴퓨터의 등장(애플 맥킨토시, MS DOS)
-   GUI(Graphic User Interface)의 등장

#### 🗓️ 1990 년대

-   GUI 환경의 개인용 컴퓨터의 보급으로 다양한 응용 프로그램 등장
    -   Excel, Word - Winow 운영체제의 대중화
-   UNIX를 기반으로 한 오픈소스 LINUX 운영체제의 등장

➡️ **CPU의 효율성과 오버헤드의 감소를 위한 고민이 끊임없이 이루어짐.**

### 📌 구조

1. **사용자**는 인터페이스를 통해 커널에 접근

    - **GUI**: 그래픽으로 커널과 상호작용으로 일반 사용자도 접근 가능
    - **CLI**: 텍스트 형태의 명령어로 커널과 상호작용

2. **어플리케이션**을 시스템 콜을 통해 커널 접근
   어플리케이션이 직접 커널에 접근하여 하드 디스크에 파일을 저장할 경우, 중요한 데이터의 손실이 발생할 수 있다. 이를 방지하기 위해 시스템 콜을 이용하여 운영체제를 통해 하드디스크의 빈 공간에 데이터를 저장한다.

3. **커널이 하드웨어**에 접근
   **드라이버**를 통해 커널은 하드웨어에 접근할 수 있다. 커널이 모든 하드웨어에 대한 드라이버를 저장할 수는 없으니, 하드웨어의 제조사에서 드라이버를 만들어 제공하고 커널이 이를 설치하면 접근 가능하다.

### 📌 컴퓨터 하드웨어와 구조

기존에는 하드웨어로 프로그램을 만들었기에, 프로그램의 수정마다 배선와 스위치를 수동으로 변경해야 한다.

#### 폰 노이만 구조 (Von Neumann Architecture)

**1. 프로그램 내장 방식**

-   프로그램과 데이터가 같은 메모리에 저장
-   실행한 명령어를 CPU가 메모리에서 읽어와 수행

**2. 순차적 명령 실행**

-   CPU는 한 번에 하나의 명령어를 순차적으로 실행

**3. 메모리, CPU, 입출력 장치로 구성**

-   **CPU(Central Pocessing Unit)**
    1. 산술논리 연산장치: 실제로 데이터 연산을 담당
    2. 제어장치: 모든 장치들의 동작을 제어하고 지시
    3. 레지스터: CPU내에 계산을 위해 임시적으로 저장하는 공간
-   **Memory**
    1. RAM: 랜덤으로 데이터를 읽어도 속도는 일정, 휘발성
    2. ROM: 전력이 끊겨도 데이터 저장이 되지만 수정 불가 (BIOS)
-   **입출력 장치**: 사용자와 컴퓨터 간 데이터 입/출력 관리

### 📌 컴퓨터 부팅 과정

1. 컴퓨터의 전원을 누름
2. ROM에 저장된 BIOS 실행
    1. CPU, RAM, 하드웨어에 이상 여부를 확인
    2. 이상이 없다면 하드디스크에 저장된 **마스터 부트 레코드**를 메모리로 올림
    3. 운영체제 동작
3. 모니터에 운영체제의 동작을 실행

#### 마스터 부트 레코드(Master Boot Record, MBR)

하드디스크, SSD, USB등 저장장치에서 부팅과 파티션 정보를 관리하는 0번 섹터

1. **부트 로더(bootloader) 저장** - BIOS가 MBR을 읽고 부트 로더를 실행하여 운영체제로 부팅
   **2. 파티션 정보 저장**
    - 디스크의 파티션 구조를 관리 (최대 4개의 파티션)
      **3. 디스크 식별**
    - 디스크의 고유한 식별 정보를 포함

### 📌 인터럽트

#### 폴링(Polling)

CPU가 지속적으로 장치나 하드웨어의 상태를 확인하여 필요한 작업을 처리하는 방식.

**- CPU의 비효율적인 자원 소모**

-   다수의 장치를 관리할 수록 CPU는 주기적으로 다수의 장치를 확인해야 하므로 다른 중요한 작업의 처리 속도가 느려질 수 있다.
    **- 상태 확인 주기와 타이밍**
-   처리가 완료되어도 다음 폴링 주기까지 기다려야 하며 사용자 응답 또한 지연된다.

#### 인터럽트(Interupt)

프로세서가 현재 실행 중인 작업을 중단하고, 중요한 작업이나 이벤트를 즉시 처리

**- 하드웨어 인터럽트**

-   시스템 외부의 하드웨어 장치에서 발생한 이벤트에 반응

**- 소프트웨어 인터럽트**

-   소프트웨어, 프로그램에 의해 발생

출처: [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)
