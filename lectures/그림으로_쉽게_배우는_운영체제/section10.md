## 💻 파일시스템

### 📌 파일과 파일 시스템

**파일 관리자**: 파일 테이블을 이용하여 파일을 관리

**파일 시스템 기능**

1. 파일, 디렉토리 생성
2. 파일, 디렉토리 수정, 삭제
3. 접근 권한 관리
4. 무결성 보장
5. 백업과 복구
6. 암호화

파일 시스템은 블록 단위로 저장장치에 전송
사용자는 바이트 단위로 파일에 접근

파일관리자가 블록 단위를 바이트로 변환

확장자를 통해 해당 파일의 연결 프로그램을 실행시킬 수 있음

운영체제는 파일제어블록(File Control Block, File Descriptor)를 갖고 있음
파일마다 독립적으로 file descriptor가 존재하고 파일이 오픈되면 메모리에 올라감
file system이 file descriptor를 관리하고 사용자는 직접 참조 불가
사용자가 파일을 실행하면 file system이 file descriptor를 전달

**파일 구조**

1. 순차파일구조: 파일의 내용이 연속적으로 이어져있음
    - file descriptor 는 파일의 첫 부분부터 시작하여 읽기, 쓰기
    - 공간 낭비가 없고 단순한 구조
    - 특정 지점으로 바로 이동이 어려워, 데이터 삽입, 삭제 시 탐색 시간이 걸림
2. 직접파일구조: 해시 함수를 통해 해시 테이블에 데이터를 저장
    - 해시 함수에 따라 키-값으로 해시 테이블 형성
    - 데이터 접근이 빠름
    - 해시 함수가 중요, 저장공간이 낭비될 수 있음
3. 인덱스파일구조: 순차 + 직접 파일 구조
    - 순차 데이터로 저장이 되어 있으며
    - 중간 데이터를 탐색하려면 인덱스 테이블에 접근하여 데이터를 가져오고
    - 해당 데이터로 순차 데이터에서 탐색하여 실행

### 📌 디렉토리

root directory: 최상위 디렉토리

윈도우 - root directory는 파티션 이름으로 사용 - C:

디렉토리 헤더는 디렉토리 정보가 시작하는 위치를 가리킴

다단계 디력토리: 하나의 디렉토리에서 하위 디렉토리를 만들 수 있는 트리 구조

-   바로 가기 기능으로 순환이 생길 수 있음

### 📌 파일과 디스크

**파일 시스템**
블록: 디스크 공간을 일정한 크기로 나누고 주소를 할당 (1 ~ 8KB)

**파일 제어 테이블**
블록의 위치 정보가 포함

하나의 파일은 여러 개의 블록으로 분할되어 있고 블록 연결 방식에 따라 **'연속할당'**과 **'불연속할당'**으로 구분

1. **연속할당**: 파일 구성 블록들을 디스크에 연속적으로 할당
    - 시작 주소만 알면 파일을 다 찾을 수 있음
    - 내부 단편화 발생 - 사용 안함
2. **불연속할당**: 데이터를 분산해 저장 - 파일 시스템이 관리
    1. **연결할당**: 파일 제어 테이블에는 시작 블록 주소만 알고 있고, 연결리스트를 통해 파일 할당 테이블에서 블록 확인
    2. **인덱스할당**: 파일 제어 테이블에 인덱스 블록의 주소를 저장, 인덱스 블록에 저장된 인덱스들로 블록들을 확인
        - 테이블이 꽉 찬경우, 인덱스 블록을 더 만들어서 테이블 확장 가능

작은 파일의 경우 inode에서 파일의 데이터 블록을 직접 가리키는 포인터를 저장
파일의 크기가 커지면 하나의 블록에 데이터를 저장할 수 없으니, 데이터 블럭을 담는 포인터 블럭을 가르킴

-   2차 (포인터-포인터-데이터) / 3차(포인터-포인터-포인터-데이터)

파일 삭제

1. 해당 파일 헤더를 제거하고
2. 사용했던 블록을 free block list에 연결
3. 사용했던 블록은 아직 남아있어서 포렌식으로 복구 가능
4. 블록은 덮어씌워지면서 재사용

### 📌 더 찾아본 점

**❓ File Descriptor 흐름**

1. `open("file.txt")` 호출
    - 파일 시스템이 FD를 생성하고 테이블에 등록
    - 사용자는 반환된 FD를 이용하여 파일 작업 수행
2. `read(fd, buffer, size)`호출
    - 파일 시스템이 블록 단위로 데이터를 읽음
    - 블록 데이터 -> 바이트로 변환 후 사용자 버퍼로 전달
3. `close(fd)` 호출
    - 파일 시스템이 FD를 테이블에서 제거하고 리소스 정리

**File Descriptor Table**을 통해 열린 파일 관리

-   FD와 실제 파일 객체 매핑
-   프로세스 별로 하나씩 갖고 있다.

**흐름**

1. 프로세스가 `open()`시에 FD가 정수로 반환
2. File Descriptor Table에 새로운 엔트리 추가 (FD: n / File Table Pointer: m)
3. File Table(프로세서가 공동 접근하는 전역 파일 테이블)에서 m에 대한 오프셋, 접근 모드, inode 포인터를 받음
4. inode Table(파일의 실제 메타데이터 저장 및 디스크 특정 블록을 가라키는 포인터)에서 inode 포인터로 저장된 블록 포인터를 확인

### 📌 백엔드 면접 질문

**✏️ Node.js에서 파일을 읽는 방법은?**

-   Node.js는 싱글스레드에서 동작하지만 내부적으로 멀티 쓰레드(Worker Pool)에서 작업을 한 후에 이벤트 루프를 통해 결과를 반환한다. 이벤트 루프는 비동기 작업에 대해 작업이 완료되면 콜백함수를 task queue에 저장하고 콜스택이 비어있으면 task queue에서 콜백함수 실행. `readFile` 메서드는 비동기로 실행되며 콜백 함수를 통해 파일 읽기 작업이 마무리되면 콜백이 실행되며 `readFileSync`는 동기적으로 실행되고 `blocking` 상태가 되어, 파일을 읽을 때까지 작업이 대기된다.

출처: [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)
