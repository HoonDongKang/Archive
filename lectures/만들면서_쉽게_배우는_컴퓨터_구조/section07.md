## 💻 메모리

### 📌 조합 논리회로

입력에 대해서만 출력하기 때문에 상태를 기억할 수 없음

-   기본 게이트, 멀티플렉서, 디코더, 반가산기, 전가산기, ALU,,

-   순차 논리회로(메모리 역할)
    출력을 다시 조합 논리회로의 입력으로 들어가야지 현재 상태를 만들어서 다음 상태를 결정시킬 수 있음

1. SR Latch
   | S | R | Q (다음 상태) | 설명 |
   | - | - | --------- | ----------- |
   | 0 | 0 | Q (유지) | 이전 상태 유지 |
   | 0 | 1 | 0 | Reset (Q=0) |
   | 1 | 0 | 1 | Set (Q=1) |
   | 1 | 1 | 무효 (X) | 금지 상태 (불안정) |

2. D latch
   | EN (CLK) | D | Q (다음 상태) | 설명 |
   | -------- | - | --------- | ----------- |
   | 0 | X | Q (유지) | 출력 유지 |
   | 1 | 0 | 0 | D의 값을 Q에 저장 |
   | 1 | 1 | 1 | D의 값을 Q에 저장 |

3. JK latch
   | J | K | CLK | Q (다음 상태) | 설명 |
   | - | - | --- | --------- | ----------------- |
   | 0 | 0 | 1 | Q (유지) | 상태 유지 |
   | 0 | 1 | 1 | 0 | Reset |
   | 1 | 0 | 1 | 1 | Set |
   | 1 | 1 | 1 | Q' (반전) | 현재 상태 반전 (Toggle) |
   | X | X | 0 | Q (유지) | CLK=0이면 상태 유지 |˚v

### 📌 클럭과 플리플롭

여러 회로의 딜레이 차이로 인해 순차적으로 결과값이 출력되고 있다. -> 원하지 않는 출력을 받게된다.

-   레지스터: 1비트 메모리 Latch를 연결해 여러 비트를 저장할 수 있는 메모리

레지스터의 enable을 0으로 바꿔서 값이 다 처리될 때까지 기다렸다가 끝나면 enable을 1로 바꿔준다.
클럭이 정해진 주기에 따라 enable을 직접 변경시켜준다.

클럭이 1인 상태에서 출력 값이 계속 바뀔 수 있다는 문제가 있다.
-> 트리거: 래치의 출력을 활성화하는 조건

1. 레벨 트리거
    1. High Level: 입력이 1인 동안에만 반영
    2. Low Level: 입력이 0인 동안에만 반영
2. 엣지 트리거
    1. Rising Edge: 0에서 1이 되었을 때 반영
    2. Falling Edge: 1에서 0이 되었을 때 반영

-> 플리플롭: 래치 트리거를 엣지 트리거로 변경하는 것

### 📌 레지스터

데이터를 출력하고 LOAD를 통해 레지스터에 저장해두었다가 Enable을 통해 출력을 통제한다.

8비트 레지스터 = 0~255까지 데이터 저장 가능

CPU내부에 있어서 적은 메모리만 저장

### 📌 RAM

1비트 저장 - 래치 || 플립플롭
8비트 저장 - 레지스터

-   MSB를 포함한 4비트 = 명령어
-   LSB를 포함한 4비트 = 메모리 주소
-   메모리 주소는 0 ~ 15번까지 사용 가능

RAM은 16개의 메모리 주소를 갖으며 하나의 메모리 주소는 8비트(1바이트)의 레지스터로 구성 => 16바이트 메모리
-> 현대 컴퓨터는 최소 4GB의 램이다.

address에서 주소를 받아서 디코더를 통해 출력된 값을 해당 메모리 주소에 연결해주면 각각의 레지스터에 값을 저장해둘 수 있다.
레지스터의 출력을 멀티플레서에 연결하고 Enable을 통해 제어하면 값을 출력할 수 있다.

출처: [만들면서 쉽게 배우는 컴퓨터 구조](https://www.inflearn.com/course/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0/dashboard)
