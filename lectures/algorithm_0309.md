**❓ 왜 가장 많은 영향을 주는 항만 도출하여 시간복잡도를 계산할까?**

✅ 해당 식의 최고차항을 제외한 모든 항과 최고차항의 계수를 제거시켜서 시간복잡도를 계산한다. 전체적인 관점에서 최고차항의 영향이 압도적으로 커치기 때문에 다른 항의 계산을 제외시킨다.

| n         | O(1) | O(log n) | O(n)   | O(n log n) | O(n²)     | O(n³)     | O(2^n)     | O(n!)       |
| --------- | ---- | -------- | ------ | ---------- | --------- | --------- | ---------- | ----------- |
| **10**    | 1    | 3.32     | 10     | 33.2       | 100       | 1000      | 1024       | 3,628,800   |
| **100**   | 1    | 6.64     | 100    | 664        | 10,000    | 1,000,000 | 1.27e+30   | 9.33e+157   |
| **1000**  | 1    | 6.97     | 1000   | 6,970      | 1,000,000 | 1e+9      | 1.07e+301  | 4.02e+2567  |
| **10000** | 1    | 9.97     | 10,000 | 99,700     | 1e+8      | 1e+12     | 1.07e+3010 | 3.32e+35659 |

**❓ 공간 복잡도(Space Complexity)**

✅ 알고리즘이 실행되는 동안 사용되는 메모리 공간의 양

**❓ 자바스크립트에서의 배열**

1. **동적 크기 조정 가능**
    - 자바스크립트 배열은 동적으로 크기가 조정된다.
    - 새로운 요소를 추가하거나 제거하면 그에 맞춰 배열의 크기가 변경된다.
2. **다양한 데이터 타입 저장 가능**
    - `number`, `string`, `boolean`, `object` 등 다양한 타입의 데이터가 배열에 저장될 수 있다.
    - 자바스크립트의 배열은 객체이기 때문에, **객체의 프로퍼티**로 모든 데이터 타입이 저장 가능하다.
3. **타입은 객체(`object`) 이지만 배열 메서드를 제공한다.**
    - `push()`, `pop()`, `map()` 등 배열에서 사용가능한 메서드를 제공한다.

**❓ `typeof([])`는 왜 `object`로 결과가 나올까?**

✅ `typeof` 연산자는 매개변수의 자료형이 **원시 값**인지, **참조 값**인지를 구분해준다. 자바스크립트 배열의 `prototype`을 보면 `Array.prototype`을 갖고 그 상위 프로토타입은 `Object.prototype`을 갖는다. 그렇기에 결국 배열은 객체의 프로토타입을 상속받고 있기에 참조값이며 `object`가 반환된다.

**❓ 원시 값, 참조 값이 뭐야?**

✅ **원시 값(Primitive Value)** 은 값이 변경될 수 없고(immutable), 직접 값이 저장되는 데이터 형태를 의미한다. 새로운 값을 변수에 저장하면 메모리 주소에 해당 값이 그대로 저장되며 변수에 값을 변경시키면 새로운 메모리에 값을 할당시킨다. 즉, 기존 메모리 주소에 저장된 값을 변경시킬 수 없다.

-   `undefined`, `boolean`, `number`, `string` ,,

**참조 값(Reference Value)** 은 값이 변경 가능(mutable)하고 참조형 데이터를 의미한다. 변수가 직접 값을 저장하는 것이 아닌 해당 값이 위치한 메모리 주소를 참조한다. 객체의 프로퍼티 값을 변경하게 되면 해당 메모리를 참조하는 모든 변수들이 영향을 받는다.

-   `Object`, `Array`, `Function`

**❓ `typeof([])`는 그럼 왜 배열 메서드를 사용할 수 있는가?**

✅ `arr → Array.prototype → Object.prototype → null` 이런 프로토타입 체인을 갖고 있기 때문에, 결국 배열은 `Array.prototype`에서 제공하는 메서드를 상속받아서 사용할 수 있다.

**❓ 해시 충돌에 대한 극복 방법**

✅ 해시 충돌(Hash Collision)을 극복하기 위해 다양한 방법들이 존재.

1. **분리 연결법(Separate Chaining)**: 해시 함수를 통해 동일한 버킷에 할당된 데이터들을 연결시켜 관리한다.
    - 간단한 구현으로 해시 테이블의 크기를 확장할 필요가 없다
    - 데이터의 양이 많아질 수록, 동일 버킷에 체이닝된 데이터가 많아진다. (쏠림 현상)
2. **개방 주소법(Open Addressing)**: 버킷에 하나의 데이터만 저장하고, 충돌 시에 비어있는 버킷에 할당
    - 동일한 규칙을 통해 비어있는 버킷을 찾아야 한다.
        1. **선형 탐색(Linear Probing)**: `index`로부터 `n`만큼 이동하여 빈 버킷 검색
        2. **제곱 탐색(Quadratic Probing)**: `index`로부터 제곱수만큼 이동하여 빈 버킷 검색(+1, +4, +9,,)
        3. **이중 해시(Doouble Hashing)**: 다른 해시함수를 한 번 더 적용
    - [선형 탐색으로 구현해본 해시 테이블](https://github.com/HoonDongKang/Archive/blob/main/lectures/%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C_%EC%89%BD%EA%B2%8C_%EB%B0%B0%EC%9A%B0%EB%8A%94_%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/src/hashTable.mjs)
