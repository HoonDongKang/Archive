## Async IO in NodeJS

원문: [Async IO in NodeJS](https://medium.com/@manikmudholkar831995/async-io-in-nodejs-a57fe9c3ccc6)

### Non-blocking IO의 필요성 이해

-   서버는 주소와 포트번호를 통해 소켓을 형성하고 클라이언트는 소켓을 통해 요청을 보내고 응답을 받는다.
-   소켓을 통한 연결은 file descriptor를 통해 접근되며, 운영체제는 요청에 연관된 데이터와 file descriptor를 kernel buffer에 저장한다.
    -   `File Descriptor`: 운영체제가 파일, 소켓, 파이프 등 입출력 리소스를 추상화한 정수
        -   열려있는 파일마다 `file descriptor`가 정수 형태로 부여되고 해당 숫자 인덱스로 데이터를 읽고 쓰기 요청
    -   `Kernel Buffer`: 운영체제 관리 메모리 공간. I/O의 중간 단계로 임시 데이터 저장소 역할
        -   소켓에 데이터가 도착하면 임시적으로 데이터를 유저에게 전달하기 전에 임시 저장
            1. 보안성과 안정성을 위해 운영체제 / 사용자 공간 분리
            2. 데이터가 한 번에 들어오지 않고 여러 번 나뉘어 도착 (버퍼에 조각 데이터를 모은 후 전달)
            3. I/O 병목현상 완화 - `read()` 호출 명령을 통해서 데이터 전달
-   애플리케이션은 이후에 시스템 콜을 통해 kernel buffer에서 데이터를 유저 메모리로 읽어온다.
-   소켓에 데이터가 아직 쓰여지지 않은 상태에서 클라이언트가 데이터를 요청하면 대기해야하며 이는 CPU 효율성을 절감시킨다.
-   어떤 작업을 실행할 때 쓰레드는 필수이다. 특히 Node.js에서 메인 쓰레드가 차단되면 애플리케이션 성능에 치명상을 줄 수 있다.
-   DNS 해석도 마찬가지로 Blocking 작업이다.
    -   OS에서 제공하는 동기식 DNS 구현체는 보통 스레드가 차단됨.

### Node.js에서 Non-Blocking IO

-   만약 데이터가 아직 버퍼에 없어 읽을 수 없다면 blocking 될 수도 있기에, Nodejs는 non-blocking 모드로 `fcntl` 시스템콜을 통해 변경시킨다.
    -   `fcntl`명령은 소켓을 non-blocking 모드로 전환하여 데이터 접근이 불가하여도 쓰레드를 block하지 않고 polling같은 방식을 통해 다시 쓰레드가 다른 작업을 하다가 다시 방문할 수 있게 설정
-   만약 100초마다 데이터 폴링을 한다면 각 커넥션은 자신의 file descriptor를 100초마다 읽을 수 있는지 모니터링함.
-   NodeJS는 더 효율적으로 OS에서 제공하는 함수를 사용
    -   `epoll`이나 `Kqueue`
    -   비동기 non-blocking IO에서 쓰레드가 유저의 데이터 쓰기를 더이상 기다리지 않는 대신 `epoll`이 읽기, 쓰기가 가능한 file descriptor를 식별한다.
-   데이터를 사용할 수 있게되면 특정 file descriptor에서 읽고 커널 메모리에 기록되며 유저 전용 메모리에 저장된다.
-   NodeJS 코드를 작성할 때는 소켓이나 커넥션에서 직접 읽지 않고 콜백을 통해 data가 사용가능해질 때 이벤트를 수신한다.
    -   `select` `poll` `epoll`이 데이터가 사용가능해질 때 알려주며 IO를 활용할 때는 read / write / recv / send와 같은 blocking 시스템 콜을 쓴다.
    -   즉, 내부적으로 깊게 OS의 blocking 시스템 콜을 통해 커널 버퍼에 접근하지만 그 상위 레이어(libuv)에 `select` `poll` `epoll` 메서드를 통해 콜백을 받게끔 설계
        1. 소켓 생성
        2. 데이터 수신
        3. `epoll`로 수신 이벤트 감지
        4. 콜백 이벤트 발생
        5. `read()`를 통해 커널 버퍼 -> 유저 메모리

### select, poll, epoll

-   웹서버 입장에서 연결에 맞는 수천 개의 파일 디스크립터를 관리하고 CPU 시간을 낭비하면서 데이터의 업데이트를 지속적으로 확인하기 어려우며 커널에게 파일 디스크립터의 수정이 발생하면 그 때 알람이 올 수 있게 요청하는 것이 더 효율적

-   이를 해결하기 위해, NodeJS는 `select` `poll` `epoll` 시스템 콜을 통해 file descriptor의 변경사항을 확인
    -   대기 시간을 통해 변경을 확인하고 타임아웃 시, 이벤트 루프의 다음 반복에 대기
-   `select`, `poll`은 파일 디스크립터의 수가 증가할수록 폴링 시간이 증가하지만 `epoll`은 이진 탐색 트리를 사용하여 성능이 우수

| operations | poll  | select | epoll |
| ---------- | ----- | ------ | ----- |
| 10         | 0.61  | 0.73   | 0.41  |
| 100        | 2.9   | 3.0    | 0.42  |
| 1000       | 35.0  | 35.0   | 0.53  |
| 10000      | 990.0 | 930.0  | 0.66  |

select/poll/epoll은 데이터의 사용 가능 여부만 알려줄 뿐, 실제 IO 작업을 수행하려면 여전히 read/write/recv/send와 같은 블로킹 시스템 콜이 필요
