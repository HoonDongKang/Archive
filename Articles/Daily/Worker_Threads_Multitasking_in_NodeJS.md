## Worker Threads : Multitasking in NodeJS

원문: [Worker Threads : Multitasking in NodeJS](https://medium.com/@manikmudholkar831995/worker-threads-multitasking-in-nodejs-6028cdf35e9d)

### worker threads를 이해하기 위한 필요조건

동시성 vs 병렬성

> 동시성은 싱글 코어에서 한 번에 여러 작업을 처리하는 것입니다. 병렬성은 멀티 코어에서 한 번에 여러 작업을 수행하는 것입니다.

동시성은 병렬성에 비해 여러 작업을 수행하는 데 더 오랜 시간이 걸릴 수 밖에 없음

-   동시성은 네트워크 통신, file/DB 읽기와 같은 I/O 작업에서 유용함
    -   CPU나 쓰레드는 그 시간동안 다른 작업을 하지 못하기에 대부분 대기 상태
    -   그 시간동안 다른 작업을 진행할 수 있기에 I/O 작업에 합리적
-   하지만 병렬성처럼 멀티 쓰레드/코어를 활용하면, 다른 워커 스레드에게 CPU 집약적인 작업을 위임하고 메인 쓰레드는 비집약적인 작업을 실행할 수 있음

> NodeJS에서는 마이크로테스크 큐에서 I/O작업이 끝나면 이벤트 루프가 콜백을 추가.
> 메인 쓰레드의 콜스택이 비어있으면 콜백이 콜스택에 추가되어 실행
> 다시 정리하면, I/O 작업의 콜백은 병렬적으로 실행되지 않지만 쓰레드의 활용으로 병렬로 처리된다.
> I/O 작업이 완료되면 콜백은 메인 스레드에서 실행

### 프로세스와 쓰레드 이해

-   프로세스는 OS에서 실행되고 있는 프로그램을 의미
-   각 프로세스는 메모리가 있으며 다른 실행 프로그램에 접근 불가
-   싱글 코어에서는 멀티 프로세스들을 정기적인 간격을 통해 스위칭을 해가며 동시에 실행
-   멀티 코어에서는 각 프로세스가 각 코어에서 동시에 실행하도록 스케쥴링
-   코어 수보다 프로세스 수가 많아지면 각 코어가 완료될 때가지 각 코어는 두 개 이상의 프로세스를 동시에 실행

-   스레드는 한 번에 하나의 작업만 가능하지만 프로세스의 메모리 안에 있기에 프로세스를 생성하면 코드를 병렬적으로 실행시킬 수 있는 여러 쓰레드가 생성될 수 있다.
-   프로세스 메모리를 통해 쓰레드간 통신이 가능
-   이런 특성 덕에 스레드는 프로세스보다 가벼우며 OS의 추가 메모리 할당받을 필요가 없음

### 살펴보기

NodeJS를 실행시키면

-   하나의 프로세스
-   하나의 스레드
-   하나의 이벤트 루프
-   하나의 V8 엔진 인스턴스
-   하나의 Node.js 인스턴스

를 갖게되며 다른 워커 스레드도 각각의 인스턴스를 갖게 된다.

V8은 자신의 JS 힙과 마이크로테스크 큐를 갖으며 고유의 엔티티를 가짐(chrome과 달리)

-   다른 워커 스레드와 분리되어 JS 코드를 실행시킬 수 있게 됨
-   워커 스레드끼리 힙 영역을 직접 접근할 수 없음
-   각 워커 스레드는 부모 스레드, 다른 스레드의 이벤트 루프와는 다른 자신만의 이벤트 루프를 가짐

워커 스레드는 부모 프로세스의 종료가 아니더라도 스스로 끝날 수 있음

-   딱히 좋은 것은 아님 (자원을 할당한 체로 쓰레드가 종료 - 메모리 누수)
-   Node.js는 각 워크 스레드마다 새로운 Node.js 인스턴스를 생성하여 각 스레드가 독립적으로 돌아감

`worker_threads`는 여러 개의 독립적인 자바스크립트 워커를 사용

-   애플리케이션에서 동시성을 제공하며
-   워커와 부모 워커 간의 통신은 Node.js에서 처리
-   스레드 간 메모리 공유는 없음
-   이벤트 기반 메시징으로 프로세스 간 값 교환 가능

각 worker는 부모 worker와 메세지 채널을 통해 연결되어 있음

1. worker initialization
    1. 워커 인스턴스 생성
    2. 부모와 자식 워커의 통신 초기화
2. worker execution
    1. 사용자가 제공한 `workerData`와 메타 데이터를 통해 워커 자바스크립트 스크립트 실행
    2. v8 인스턴스 생성 및 이벤트 루프 초기화
    3. 초기화 메타데이터와 함께 worker 스레드 실행

### message channel

스레드간 통신을 위해 통신 채널과 포트가 중요

MessageChannel은 양방향 채널, `nes MessageChannel()`로 호출하면 서로 연결된 인스턴스의 `port1`, `port2`를 반환

### Atomics

동일한 공유 자원에 대해 여러 스레드가 접근하면 race condition 발생

`Atomics` 연산자를 통해 하나의 연산이 끝날 때까지 다른 연산 시작을 안함.

### Worker thread gotchas

1. NodeJS 워커 스레드는 일반적으로 통용되는 스레드는 아니다. 각 워커 스레드마다 독립적인 인스턴스들이 있음(v8, nodejs, libuv, 이벤트 루프,,)
2. I/O를 위해 워커 스레드를 만드는 것은 비효율적
3. 워커 스레드의 공유 풀을 활용하면 비효율성을 줄이고 새로운 프로세스 생성을 줄일 수 있음
4. 워커 스레드 디버깅은 이벤트와 해당 워커, 결과 사이간 명확한 연결이 부족하여 상당히 어려움
    1. 워커풀에 AsyncResource를 연결하면 풀 내에 활동을 정확히 추적 가능
5. 코어 개수보다 더 많은 스레드 생성하면 컨텍스트 스위칭에 CPU 사용률 낭비
